# Javascript Function

## 재귀와 스택

### 실행 컨텍스트

1. `실행 컨텍스트`는 함수 실행에 대한 세부 정보를 담고 있는 내부 데이터 구조이다.
    - 제어 흐름의 현재 위치
    - 변수의 현재 값
    - this의 값 등
2. 함수 호출 일 회당 하나의 실행 컨텍스트가 생성된다.

### 재귀

1. `재귀`는 문제 해결 단계에서 자기 자신을 참조하는 경우를 말한다.
2. 재귀는 작업을 동일한 여러 작업의 반복으로 나타낼 수 있을 떄 유용하다.

    ```js
    function pow(x, n) {
    	if (n == 1) {
    		return x;
    	} else {
    		return x * pow(x, n - 1); // 재귀적 사고를 통한 방법
    	}
    }

    alert(pow(2, 3)); // 8
    ```

    위의 예시에서 x를 n제곱하는 함수 pow(x, n)는 pow(x, n-1)의 반복으로 나타낼 수 있다. 재귀 단계는 n == 1이 될 때까지 계속 이루어진다.

3. 재귀의 구성 요소는 다음과 같다.
    - `재귀의 베이스` : 명확한 결괏값을 즉시 도출
    - `재귀 단계` : 자기 자신을 호출
    - `재귀 깊이` : 중첩 호출의 최대 개수
      </br> 재귀 단계는 제귀의 베이스에 도달할 때까지 계속 이어진다.
4. 재귀를 사용하면 코드가 짧아지고 코드 이해도가 높아지며 유지보수에도 이점이 있다.

### 재귀 함수의 실행

1. 재귀 함수 실행시 (즉, 함수 내부에 중첩 호출이 있을 경우) 아래와 같은 절차가 수행된다.
    - 현재 함수을 실행이 일시 중지
    - 중지된 함수와 연관된 실행 컨텍스트를 `실행 컨텍스트 스택`(execution context stack)에 저장
    - 중첩 호출 실행
    - 중첩 호출 실행이 끝난 이후, 실행 컨텍스트 스택에서 일시 중단한 함수의 실행 컨텍스트를 꺼내고 중단한 함수를 다시 실행

### 연결 리스트

1. 재귀적으로 정의된 자료구조인 `재귀적 자료 구조`는 자기 자신의 일부를 복제하는 형태의 자료 구조이다.
2. `연결 리스트`는 객체 형태로, `value`와 `next`라는 프로퍼티를 가진다.
    - value
    - next : 다음 연결 리스트 요소를 참조하는 프로퍼티
      </br> 다음 요소가 없을 땐 null값을 가진다.
    ```js
    let list = {
    	value: 1,
    	next: {
    		value: 2,
    		next: {
    			value: 3,
    			next: {
    				value: 4,
    				next: null,
    			},
    		},
    	},
    };
    ```
3. 연결 리스트를 사용하면 전체 리스트를 여러 부분으로 쉽게 나눌 수 있고, 나누어진 것을 다시 합치기 수월하다.

    ```js
    let secondList = list.next.next;
    list.next.next = null; // 나누기

    list.next.next = secondList; // 합치기
    ```

4. 리스트의 처음 객체를 바꾸면 리스트 맨 앞에 새로운 값을 추가할 수 있다.
    ```js
    list = { value: "new", next: list };
    ```
5. 중간 요소를 제거하는 것도 간편하게 할 수 있다.
    ```js
    list.next.next = list.next.next.next;
    // list.next.next 값을 삭제하고 한 칸씩 땡겨옴
    ```
6. 연결 리스트는 인덱스를 통해 요소에 접근할 수 없다는 단점이 있다. 적절한 구조 변경을 통해 연결 리스트의 구조를 개선하는 것이 필요하다.
    - 이전 요소 참조 프로퍼티 추가
    - 마지막 요소 참조 변수 추가 등

---

### ...

1. ...이 함수 매개변수의 끝에 있으면 인수 목록의 나머지를 배열로 모아주는 `나머지 매개변수`이다.
2. ...이 함수 호출 시 사용되거나 기타 경우엔 배열을 목록으로 확장해주는 `스프레드 문법`이다.

---

## 렉시컬 환경

1. `렉시컬 환경`은 스크립트와 관련된 내용을 담는 내부 숨김 연관 객체이다.
    - 스크립트 전체와 관련된 렉시컬 환경은 `전역 렉시컬 환경`이라 부른다.
2. 렉시컬 환경은 다음 두가지 부분으로 구성된다.
    - `환경 레코드` : 모든 지역 변수를 프로퍼티로 저장한다.
    - `외부 렉시컬 환경` : 외부 코드에와 연관되어있다.
3. 스크립트가 실행되면서 렉시컬 환경은 변화한다.

### 변수와 렉시컬 환경

1. 스크립트가 시작되면 스크립트 내에서 선언한 변수 전체가 렉시컬 환경에 올라간다. 이때, 변수는 프로퍼티 값으로 `uninitialized`이라는 특수 내부 상태를 갖는다.
   </br>자바스크립트 엔진은 변수를 인지하긴 하지만, 변수의 선언자 (`let` 또는 `const`)를 만나기 전까진 이 변수를 참조할 수 없다.
2. 변수의 선언자를 만나면 변수의 프로퍼티 값은 `undefined`가 된다.
3. 변수의 값이 할당되면 할당된 값을 프로퍼티 값으로 가지게 된다.
4. 변수의 값에 변화가 생기면 프로퍼티 값도 변화한다.

### 함수와 렉시컬 환경

1. 함수 선언문(`function ~`)으로 선언한 함수는 스크립트가 시작됨과 동시에 바로 초기화된다.
   </br> 함수 명을 프로퍼티 키로, `function`을 프로퍼티 값으로 갖는다.
2. 함수 표현식으로 선언한 함수는 변수와 동일한 절차를 따른다.
3. 함수를 호출해 실행하면 함수 내부에 대한 새로운 렉시컬 환경이 만들어진다. 이때, 내부 렉시컬 환경은 외부 렉시컬 환경에 대한 참조를 가진다.
    - 내부 렉시컬 환경 : 현재 실행중인 함수에 대한 환경. 내부 렉시컬 환경에 대한 인자와 함수 내부에서 선언한 변수에 대한 프로퍼티를 가진다.
    - 외부 렉시컬 환경 : 함수 바깥의 렉시컬 환경을 가리킨다.
4. 모든 함수는 `[[Environment]]`라 불리는 숨김 프로퍼티를 갖는데, 이는 함수가 만들어진 곳의 렉시컬 환경에 대한 참조가 저장된다.
    - 자바스크립트의 모든 함수는 `클로저`이다. `[[Environment]]`프로퍼티 덕분에 외부 변수를 기억하고, 이 외부 변수에 접근할 수 있기 때문이다.

### 코드 실행시 변수 접근 방법

1. 내부 렉시컬 환경을 검색 범위로 잡는다.
2. 내부 렉시컬 환경에서 원하는 변수를 찾지 못하면 외부 렉시컬 환경으로 검색 범위를 확장한다.
3. 전역 렉시컬 환경에 도달할 때까지 변수를 찾지 못하면 에러가 발생한다. (엄격모드 기준)
4. 변숫값 갱신은 변수가 저장된 렉시컬 환경에서 이루어진다.

### 렉시컬 환경과 가비지 컬렉션

1. 함수 호출이 끝나면 함수에 대응하는 렉시컬 환경은 메모리에서 제거된다.
2. 중첩 함수의 경우, 해당 렉시컬 환경 객체를 참조하는 중첩 함수가 하나라도 있으면 사라지지 않으므로 주의해야 한다.

---

## 전역 객체

1. 전역 객체는 언어 자체나 호스트 환경에 기본 내장되어있는 경우가 많다.
   </br> 예를 들어, 브라우저 환경에는 `window`, Node.js 환경에는 `global`이라 불리는 전역 객체가 내장되어 있다.
2. 전역 객체를 사용하면 어디서나 사용 가능한 변수나 함수를 만들 수 있다.
3. 전역 객체에 프로퍼티를 추가하여 모든 스크립트에서 프로퍼티에 접근 가능하게 할 수 있다.

    ```js
    window.propertyKey = {
    	key: value,
    };

    console.log(propertyKey.key); // 선언 없이 모든 스크립트에서 접근 가능
    console.log(window.propertyKey.key); // 지역 변수와 충돌시 해당 방법으로 접근 가능
    ```

4. 프로젝트 전체에서 꼭 필요한 변수만 전역 객체에 저장하도록 하고, 전역 변수는 가능한 한 최소한으로 사용하는 것이 바람직하다.

---

## 함수 객체의 프로퍼티

1. 함수는 객체이다.
2. `name` 프로퍼티를 이용하면 함수의 이름을 가져올 수 있다.
3. `length` 프로퍼티를 이용하면 함수 매개변수의 개수를 반환한다. (단, 나머지 매개변수는 개수에 포함되지 않는다.)
4. 함수에 자체적으로 만든 프로퍼티를 추가할 수도 있다. 함수 프로퍼티는 값은 외부에서 수정 가능하다.

### 기명 함수 표현식

1. 기명 함수 표현식은 이름이 있는 함수 표현식을 나타낸다.
2. 기명 함수가 갖는 이름은 함수 내에서 사용 가능하다. 즉, 함수 내에서 자기 자신을 호출할 수 있다.
    ```js
    let sayHi = function func(who) {
    	if (who) {
    		alert(`Hello, ${who}`);
    	} else {
    		func("Guest"); // 원하는 값이 제대로 출력됩니다.
    	}
    };
    ```
    </br> 기명 함수의 이름은 함수 지역(locsl) 수준에 존재하므로 외부 렉시컬 환경에서 찾지 않아도 된다.

---

## 생성자 new를 이용한 함수 선언

1. `new Function (["arg1", "arg2", ...], "body")` 문법을 이용하여 함수를 선언할 수 있다.
2. new를 이용해 선언한 함수는 함수 본문을 문자열의 형태로 가진다.
3. new를 이용해 선언한 함수의 `[[Environment]]`는 전역 렉시컬 환경을 참조하므로 오직 전역 변수에만 접근할 수 있다.

### new Function과 압축기

1. 압축기는 스크립트에서 주석이나 여분의 공백 등을 없애 코드 크기를 줄여주는 특수한 프로그램이다.
2. 압축기는 지역 변수 이름을 짧게 교체한다. 일반적으로, 함수 외부에선 함수 내부의 지역 변수에 접근하지 않기 때문에 문제가 발생하지 않는다.
3. new를 사용해 선언한 함수가 외부 변수에 접근하려고 하면, 외부변수는 압축기에 의해 이미 이름이 변경되어 찾을 수 없는 경우가 발생한다.
4. new Function으로 만든 함수에 무언갈 넘겨주고 싶다면 인수를 사용하는 것이 바람직하다.

---

## 함수 호출 스케줄링

1. `setInterval(function, millisecond, [arg1], [arg2], ...)` : millisecond마다 function이 실행된다.
2. `setTimeout(function, millisecond, [arg1], [arg2], ...)` : millisecond 이후 function을 실행한다.
3. `중첩 setTimeout`을 이용하면 호출 결과에 따라 다음 호출을 유연하게 조정할 수 있다.

### 스케줄링 취소

1. setInterval이나 setTimeout을 호출하면 `타이머 식별자(timerIdentifier)`가 반환된다.
2. `clearTimeout(timerIdentifier)`을 이용하면 스케줄링을 취소할 수 있다.

### 자연 간격

1. 지연 간격이란 함수가 실행된 후 다음 함수가 실행될 때까지의 시간을 의미한다.
2. `setInterval`의 경우 함수가 실행되자마자 시간을 재기 때문에 지연 간격은 인수로 받은 지연 시간보다 줄어든다.
3. `setTimeout`의 경우 함수가 종료된 후 시간을 재기 때문에 지연 간격이 인수로 받은 지연 시간과 동일하다.
4. 스케줄링 메서드를 사용할 땐 명시한 지연 간격이 보장되지 않을 수도 있다는 점에 유의해야 한다.

---

## 화살표 함수의 특징

1. 화살표 함수는 `(매개변수) => {실행문}`의 형태를 지니는 함수의 한 종류이다.
2. 화살표 함수는 자체 '컨텍스트’가 없는 짧은 코드를 담을 용도로 만들어졌다. 따라서 지원되지 않는 기능들이 존재한다.

### 화살표 함수가 할 수 없는 것들

1. 화살표 함수는 this를 가지지 않는다. 대신 화살효 함수의 외부에서 this를 가져와서 사용한다.
   </br> 이러한 특징은 객체의 메서드 안에서 객체의 프로퍼티를 대상으로 순회하는 데 유용하다.
2. 화살표 함수는 new와 함께 호출할 수 없다. 이 역시 this가 없기 때문이다.
3. 화살표 함수는 모든 인수에 접근할 수 있게 해주는 유사 배열 객체 arguments를 지원하지 않는다.
4. 화살표 함수는 super가 없다.
